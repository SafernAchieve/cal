{"ast":null,"code":"(function (name, definition) {\n  /****************\n   *  A tolerant, minimal icalendar parser\n   *  (http://tools.ietf.org/html/rfc5545)\n   *\n   *  <peterbraden@peterbraden.co.uk>\n   * **************/\n\n  if (typeof module !== 'undefined') {\n    module.exports = definition();\n  } else if (typeof define === 'function' && typeof define.amd === 'object') {\n    define(definition);\n  } else {\n    this[name] = definition();\n  }\n})('ical', function () {\n  // Unescape Text re RFC 4.3.11\n  var text = function (t) {\n    t = t || \"\";\n    return t.replace(/\\\\\\,/g, ',').replace(/\\\\\\;/g, ';').replace(/\\\\[nN]/g, '\\n').replace(/\\\\\\\\/g, '\\\\');\n  };\n  var parseParams = function (p) {\n    var out = {};\n    for (var i = 0; i < p.length; i++) {\n      if (p[i].indexOf('=') > -1) {\n        var segs = p[i].split('=');\n        out[segs[0]] = parseValue(segs.slice(1).join('='));\n      }\n    }\n    return out || sp;\n  };\n  var parseValue = function (val) {\n    if ('TRUE' === val) return true;\n    if ('FALSE' === val) return false;\n    var number = Number(val);\n    if (!isNaN(number)) return number;\n    return val;\n  };\n  var storeValParam = function (name) {\n    return function (val, curr) {\n      var current = curr[name];\n      if (Array.isArray(current)) {\n        current.push(val);\n        return curr;\n      }\n      if (current != null) {\n        curr[name] = [current, val];\n        return curr;\n      }\n      curr[name] = val;\n      return curr;\n    };\n  };\n  var storeParam = function (name) {\n    return function (val, params, curr) {\n      var data;\n      if (params && params.length && !(params.length == 1 && params[0] === 'CHARSET=utf-8')) {\n        data = {\n          params: parseParams(params),\n          val: text(val)\n        };\n      } else data = text(val);\n      return storeValParam(name)(data, curr);\n    };\n  };\n  var addTZ = function (dt, params) {\n    var p = parseParams(params);\n    if (params && p) {\n      dt.tz = p.TZID;\n      if (dt.tz !== undefined) {\n        // Remove surrouding quotes if found at the begining and at the end of the string\n        // (Occurs when parsing Microsoft Exchange events containing TZID with Windows standard format instead IANA)\n        dt.tz = dt.tz.replace(/^\"(.*)\"$/, \"$1\");\n      }\n    }\n    return dt;\n  };\n  var dateParam = function (name) {\n    return function (val, params, curr) {\n      var newDate = text(val);\n      if (params && params[0] === \"VALUE=DATE\") {\n        // Just Date\n\n        var comps = /^(\\d{4})(\\d{2})(\\d{2})$/.exec(val);\n        if (comps !== null) {\n          // No TZ info - assume same timezone as this computer\n          newDate = new Date(comps[1], parseInt(comps[2], 10) - 1, comps[3]);\n          newDate = addTZ(newDate, params);\n          newDate.dateOnly = true;\n\n          // Store as string - worst case scenario\n          return storeValParam(name)(newDate, curr);\n        }\n      }\n\n      //typical RFC date-time format\n      var comps = /^(\\d{4})(\\d{2})(\\d{2})T(\\d{2})(\\d{2})(\\d{2})(Z)?$/.exec(val);\n      if (comps !== null) {\n        if (comps[7] == 'Z') {\n          // GMT\n          newDate = new Date(Date.UTC(parseInt(comps[1], 10), parseInt(comps[2], 10) - 1, parseInt(comps[3], 10), parseInt(comps[4], 10), parseInt(comps[5], 10), parseInt(comps[6], 10)));\n          // TODO add tz\n        } else {\n          newDate = new Date(parseInt(comps[1], 10), parseInt(comps[2], 10) - 1, parseInt(comps[3], 10), parseInt(comps[4], 10), parseInt(comps[5], 10), parseInt(comps[6], 10));\n        }\n        newDate = addTZ(newDate, params);\n      }\n\n      // Store as string - worst case scenario\n      return storeValParam(name)(newDate, curr);\n    };\n  };\n  var geoParam = function (name) {\n    return function (val, params, curr) {\n      storeParam(val, params, curr);\n      var parts = val.split(';');\n      curr[name] = {\n        lat: Number(parts[0]),\n        lon: Number(parts[1])\n      };\n      return curr;\n    };\n  };\n  var categoriesParam = function (name) {\n    var separatorPattern = /\\s*,\\s*/g;\n    return function (val, params, curr) {\n      storeParam(val, params, curr);\n      if (curr[name] === undefined) curr[name] = val ? val.split(separatorPattern) : [];else if (val) curr[name] = curr[name].concat(val.split(separatorPattern));\n      return curr;\n    };\n  };\n\n  // EXDATE is an entry that represents exceptions to a recurrence rule (ex: \"repeat every day except on 7/4\").\n  // The EXDATE entry itself can also contain a comma-separated list, so we make sure to parse each date out separately.\n  // There can also be more than one EXDATE entries in a calendar record.\n  // Since there can be multiple dates, we create an array of them.  The index into the array is the ISO string of the date itself, for ease of use.\n  // i.e. You can check if ((curr.exdate != undefined) && (curr.exdate[date iso string] != undefined)) to see if a date is an exception.\n  // NOTE: This specifically uses date only, and not time.  This is to avoid a few problems:\n  //    1. The ISO string with time wouldn't work for \"floating dates\" (dates without timezones).\n  //       ex: \"20171225T060000\" - this is supposed to mean 6 AM in whatever timezone you're currently in\n  //    2. Daylight savings time potentially affects the time you would need to look up\n  //    3. Some EXDATE entries in the wild seem to have times different from the recurrence rule, but are still excluded by calendar programs.  Not sure how or why.\n  //       These would fail any sort of sane time lookup, because the time literally doesn't match the event.  So we'll ignore time and just use date.\n  //       ex: DTSTART:20170814T140000Z\n  //             RRULE:FREQ=WEEKLY;WKST=SU;INTERVAL=2;BYDAY=MO,TU\n  //             EXDATE:20171219T060000\n  //       Even though \"T060000\" doesn't match or overlap \"T1400000Z\", it's still supposed to be excluded?  Odd. :(\n  // TODO: See if this causes any problems with events that recur multiple times a day.\n  var exdateParam = function (name) {\n    return function (val, params, curr) {\n      var separatorPattern = /\\s*,\\s*/g;\n      curr[name] = curr[name] || [];\n      var dates = val ? val.split(separatorPattern) : [];\n      dates.forEach(function (entry) {\n        var exdate = new Array();\n        dateParam(name)(entry, params, exdate);\n        if (exdate[name]) {\n          if (typeof exdate[name].toISOString === 'function') {\n            curr[name][exdate[name].toISOString().substring(0, 10)] = exdate[name];\n          } else {\n            console.error(\"No toISOString function in exdate[name]\", exdate[name]);\n          }\n        }\n      });\n      return curr;\n    };\n  };\n\n  // RECURRENCE-ID is the ID of a specific recurrence within a recurrence rule.\n  // TODO:  It's also possible for it to have a range, like \"THISANDPRIOR\", \"THISANDFUTURE\".  This isn't currently handled.\n  var recurrenceParam = function (name) {\n    return dateParam(name);\n  };\n  var addFBType = function (fb, params) {\n    var p = parseParams(params);\n    if (params && p) {\n      fb.type = p.FBTYPE || \"BUSY\";\n    }\n    return fb;\n  };\n  var freebusyParam = function (name) {\n    return function (val, params, curr) {\n      var fb = addFBType({}, params);\n      curr[name] = curr[name] || [];\n      curr[name].push(fb);\n      storeParam(val, params, fb);\n      var parts = val.split('/');\n      ['start', 'end'].forEach(function (name, index) {\n        dateParam(name)(parts[index], params, fb);\n      });\n      return curr;\n    };\n  };\n  return {\n    objectHandlers: {\n      'BEGIN': function (component, params, curr, stack) {\n        stack.push(curr);\n        return {\n          type: component,\n          params: params\n        };\n      },\n      'END': function (component, params, curr, stack) {\n        // prevents the need to search the root of the tree for the VCALENDAR object\n        if (component === \"VCALENDAR\") {\n          //scan all high level object in curr and drop all strings\n          var key, obj;\n          for (key in curr) {\n            if (curr.hasOwnProperty(key)) {\n              obj = curr[key];\n              if (typeof obj === 'string') {\n                delete curr[key];\n              }\n            }\n          }\n          return curr;\n        }\n        var par = stack.pop();\n        if (curr.uid) {\n          // If this is the first time we run into this UID, just save it.\n          if (par[curr.uid] === undefined) {\n            par[curr.uid] = curr;\n          } else {\n            // If we have multiple ical entries with the same UID, it's either going to be a\n            // modification to a recurrence (RECURRENCE-ID), and/or a significant modification\n            // to the entry (SEQUENCE).\n\n            // TODO: Look into proper sequence logic.\n\n            if (curr.recurrenceid === undefined) {\n              // If we have the same UID as an existing record, and it *isn't* a specific recurrence ID,\n              // not quite sure what the correct behaviour should be.  For now, just take the new information\n              // and merge it with the old record by overwriting only the fields that appear in the new record.\n              var key;\n              for (key in curr) {\n                par[curr.uid][key] = curr[key];\n              }\n            }\n          }\n\n          // If we have recurrence-id entries, list them as an array of recurrences keyed off of recurrence-id.\n          // To use - as you're running through the dates of an rrule, you can try looking it up in the recurrences\n          // array.  If it exists, then use the data from the calendar object in the recurrence instead of the parent\n          // for that day.\n\n          // NOTE:  Sometimes the RECURRENCE-ID record will show up *before* the record with the RRULE entry.  In that\n          // case, what happens is that the RECURRENCE-ID record ends up becoming both the parent record and an entry\n          // in the recurrences array, and then when we process the RRULE entry later it overwrites the appropriate\n          // fields in the parent record.\n\n          if (curr.recurrenceid != null) {\n            // TODO:  Is there ever a case where we have to worry about overwriting an existing entry here?\n\n            // Create a copy of the current object to save in our recurrences array.  (We *could* just do par = curr,\n            // except for the case that we get the RECURRENCE-ID record before the RRULE record.  In that case, we\n            // would end up with a shared reference that would cause us to overwrite *both* records at the point\n            // that we try and fix up the parent record.)\n            var recurrenceObj = new Object();\n            var key;\n            for (key in curr) {\n              recurrenceObj[key] = curr[key];\n            }\n            if (recurrenceObj.recurrences != undefined) {\n              delete recurrenceObj.recurrences;\n            }\n\n            // If we don't have an array to store recurrences in yet, create it.\n            if (par[curr.uid].recurrences === undefined) {\n              par[curr.uid].recurrences = new Array();\n            }\n\n            // Save off our cloned recurrence object into the array, keyed by date but not time.\n            // We key by date only to avoid timezone and \"floating time\" problems (where the time isn't associated with a timezone).\n            // TODO: See if this causes a problem with events that have multiple recurrences per day.\n            if (typeof curr.recurrenceid.toISOString === 'function') {\n              par[curr.uid].recurrences[curr.recurrenceid.toISOString().substring(0, 10)] = recurrenceObj;\n            } else {\n              console.error(\"No toISOString function in curr.recurrenceid\", curr.recurrenceid);\n            }\n          }\n\n          // One more specific fix - in the case that an RRULE entry shows up after a RECURRENCE-ID entry,\n          // let's make sure to clear the recurrenceid off the parent field.\n          if (par[curr.uid].rrule != undefined && par[curr.uid].recurrenceid != undefined) {\n            delete par[curr.uid].recurrenceid;\n          }\n        } else par[Math.random() * 100000] = curr; // Randomly assign ID : TODO - use true GUID\n\n        return par;\n      },\n      'SUMMARY': storeParam('summary'),\n      'DESCRIPTION': storeParam('description'),\n      'URL': storeParam('url'),\n      'UID': storeParam('uid'),\n      'LOCATION': storeParam('location'),\n      'DTSTART': dateParam('start'),\n      'DTEND': dateParam('end'),\n      'EXDATE': exdateParam('exdate'),\n      ' CLASS': storeParam('class'),\n      'TRANSP': storeParam('transparency'),\n      'GEO': geoParam('geo'),\n      'PERCENT-COMPLETE': storeParam('completion'),\n      'COMPLETED': dateParam('completed'),\n      'CATEGORIES': categoriesParam('categories'),\n      'FREEBUSY': freebusyParam('freebusy'),\n      'DTSTAMP': dateParam('dtstamp'),\n      'CREATED': dateParam('created'),\n      'LAST-MODIFIED': dateParam('lastmodified'),\n      'RECURRENCE-ID': recurrenceParam('recurrenceid')\n    },\n    handleObject: function (name, val, params, ctx, stack, line) {\n      var self = this;\n      if (self.objectHandlers[name]) return self.objectHandlers[name](val, params, ctx, stack, line);\n\n      //handling custom properties\n      if (name.match(/X\\-[\\w\\-]+/) && stack.length > 0) {\n        //trimming the leading and perform storeParam\n        name = name.substring(2);\n        return storeParam(name)(val, params, ctx, stack, line);\n      }\n      return storeParam(name.toLowerCase())(val, params, ctx);\n    },\n    getLineBreakChar: function (string) {\n      const indexOfLF = string.indexOf('\\n', 1); // No need to check first-character\n\n      if (indexOfLF === -1) {\n        if (string.indexOf('\\r') !== -1) return '\\r';\n        return '\\n';\n      }\n      if (string[indexOfLF - 1] === '\\r') return '\\r?\\n';\n      return '\\n';\n    },\n    parseICS: function (str) {\n      var self = this;\n      var line_end_type = self.getLineBreakChar(str);\n      var lines = str.split(line_end_type == '\\n' ? /\\n/ : /\\r?\\n/);\n      var ctx = {};\n      var stack = [];\n      for (var i = 0, ii = lines.length, l = lines[0]; i < ii; i++, l = lines[i]) {\n        //Unfold : RFC#3.1\n        while (lines[i + 1] && /[ \\t]/.test(lines[i + 1][0])) {\n          l += lines[i + 1].slice(1);\n          i += 1;\n        }\n\n        // Split on semicolons except if the semicolon is surrounded by quotes\n        var kv = l.split(/:(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/g);\n        if (kv.length < 2) {\n          // Invalid line - must have k&v\n          continue;\n        }\n\n        // Although the spec says that vals with colons should be quote wrapped\n        // in practise nobody does, so we assume further colons are part of the\n        // val\n        var value = kv.slice(1).join(\":\"),\n          kp = kv[0].split(\";\"),\n          name = kp[0],\n          params = kp.slice(1);\n        ctx = self.handleObject(name, value, params, ctx, stack, l) || {};\n      }\n\n      // type and params are added to the list of items, get rid of them.\n      delete ctx.type;\n      delete ctx.params;\n      return ctx;\n    }\n  };\n});","map":{"version":3,"names":["name","definition","module","exports","define","amd","text","t","replace","parseParams","p","out","i","length","indexOf","segs","split","parseValue","slice","join","sp","val","number","Number","isNaN","storeValParam","curr","current","Array","isArray","push","storeParam","params","data","addTZ","dt","tz","TZID","undefined","dateParam","newDate","comps","exec","Date","parseInt","dateOnly","UTC","geoParam","parts","lat","lon","categoriesParam","separatorPattern","concat","exdateParam","dates","forEach","entry","exdate","toISOString","substring","console","error","recurrenceParam","addFBType","fb","type","FBTYPE","freebusyParam","index","objectHandlers","BEGIN","component","stack","END","key","obj","hasOwnProperty","par","pop","uid","recurrenceid","recurrenceObj","Object","recurrences","rrule","Math","random","handleObject","ctx","line","self","match","toLowerCase","getLineBreakChar","string","indexOfLF","parseICS","str","line_end_type","lines","ii","l","test","kv","value","kp"],"sources":["C:/Users/Safern/Downloads/cal/node_modules/ical/ical.js"],"sourcesContent":["(function(name, definition) {\n\n/****************\n *  A tolerant, minimal icalendar parser\n *  (http://tools.ietf.org/html/rfc5545)\n *\n *  <peterbraden@peterbraden.co.uk>\n * **************/\n\n  if (typeof module !== 'undefined') {\n    module.exports = definition();\n  } else if (typeof define === 'function' && typeof define.amd === 'object'){\n    define(definition);\n  } else {\n    this[name] = definition();\n  }\n\n}('ical', function(){\n\n   // Unescape Text re RFC 4.3.11\n  var text = function(t){\n    t = t || \"\";\n    return (t\n      .replace(/\\\\\\,/g, ',')\n      .replace(/\\\\\\;/g, ';')\n      .replace(/\\\\[nN]/g, '\\n')\n      .replace(/\\\\\\\\/g, '\\\\')\n    )\n  }\n\n  var parseParams = function(p){\n    var out = {}\n    for (var i = 0; i<p.length; i++){\n      if (p[i].indexOf('=') > -1){\n        var segs = p[i].split('=');\n\n        out[segs[0]] = parseValue(segs.slice(1).join('='));\n\n      }\n    }\n    return out || sp\n  }\n\n  var parseValue = function(val){\n    if ('TRUE' === val)\n      return true;\n\n    if ('FALSE' === val)\n      return false;\n\n    var number = Number(val);\n    if (!isNaN(number))\n      return number;\n\n    return val;\n  }\n\n  var storeValParam = function (name) {\n      return function (val, curr) {\n          var current = curr[name];\n          if (Array.isArray(current)) {\n              current.push(val);\n              return curr;\n          }\n\n          if (current != null) {\n              curr[name] = [current, val];\n              return curr;\n          }\n\n          curr[name] = val;\n          return curr\n      }\n  }\n\n  var storeParam = function (name) {\n      return function (val, params, curr) {\n          var data;\n          if (params && params.length && !(params.length == 1 && params[0] === 'CHARSET=utf-8')) {\n              data = { params: parseParams(params), val: text(val) }\n          }\n          else\n              data = text(val)\n\n          return storeValParam(name)(data, curr);\n      }\n  }\n\n  var addTZ = function (dt, params) {\n    var p = parseParams(params);\n\n    if (params && p){\n      dt.tz = p.TZID\n      if (dt.tz !== undefined)\n      {\n        // Remove surrouding quotes if found at the begining and at the end of the string\n        // (Occurs when parsing Microsoft Exchange events containing TZID with Windows standard format instead IANA)\n        dt.tz = dt.tz.replace(/^\"(.*)\"$/, \"$1\")\n      }\n    }\n\n    return dt\n  }\n\n  var dateParam = function(name){\n      return function (val, params, curr) {\n\n      var newDate = text(val);\n\n\n      if (params && params[0] === \"VALUE=DATE\") {\n        // Just Date\n\n        var comps = /^(\\d{4})(\\d{2})(\\d{2})$/.exec(val);\n        if (comps !== null) {\n          // No TZ info - assume same timezone as this computer\n          newDate = new Date(\n            comps[1],\n            parseInt(comps[2], 10)-1,\n            comps[3]\n          );\n\n          newDate = addTZ(newDate, params);\n          newDate.dateOnly = true;\n\n          // Store as string - worst case scenario\n          return storeValParam(name)(newDate, curr)\n        }\n      }\n\n\n      //typical RFC date-time format\n      var comps = /^(\\d{4})(\\d{2})(\\d{2})T(\\d{2})(\\d{2})(\\d{2})(Z)?$/.exec(val);\n      if (comps !== null) {\n        if (comps[7] == 'Z'){ // GMT\n          newDate = new Date(Date.UTC(\n            parseInt(comps[1], 10),\n            parseInt(comps[2], 10)-1,\n            parseInt(comps[3], 10),\n            parseInt(comps[4], 10),\n            parseInt(comps[5], 10),\n            parseInt(comps[6], 10 )\n          ));\n          // TODO add tz\n        } else {\n          newDate = new Date(\n            parseInt(comps[1], 10),\n            parseInt(comps[2], 10)-1,\n            parseInt(comps[3], 10),\n            parseInt(comps[4], 10),\n            parseInt(comps[5], 10),\n            parseInt(comps[6], 10)\n          );\n        }\n\n        newDate = addTZ(newDate, params);\n    }\n\n\n          // Store as string - worst case scenario\n      return storeValParam(name)(newDate, curr)\n      }\n  }\n\n\n  var geoParam = function(name){\n    return function(val, params, curr){\n      storeParam(val, params, curr)\n      var parts = val.split(';');\n      curr[name] = {lat:Number(parts[0]), lon:Number(parts[1])};\n      return curr\n    }\n  }\n\n  var categoriesParam = function (name) {\n    var separatorPattern = /\\s*,\\s*/g;\n    return function (val, params, curr) {\n      storeParam(val, params, curr)\n      if (curr[name] === undefined)\n        curr[name] = val ? val.split(separatorPattern) : []\n      else\n        if (val)\n          curr[name] = curr[name].concat(val.split(separatorPattern))\n      return curr\n    }\n  }\n\n  // EXDATE is an entry that represents exceptions to a recurrence rule (ex: \"repeat every day except on 7/4\").\n  // The EXDATE entry itself can also contain a comma-separated list, so we make sure to parse each date out separately.\n  // There can also be more than one EXDATE entries in a calendar record.\n  // Since there can be multiple dates, we create an array of them.  The index into the array is the ISO string of the date itself, for ease of use.\n  // i.e. You can check if ((curr.exdate != undefined) && (curr.exdate[date iso string] != undefined)) to see if a date is an exception.\n  // NOTE: This specifically uses date only, and not time.  This is to avoid a few problems:\n  //    1. The ISO string with time wouldn't work for \"floating dates\" (dates without timezones).\n  //       ex: \"20171225T060000\" - this is supposed to mean 6 AM in whatever timezone you're currently in\n  //    2. Daylight savings time potentially affects the time you would need to look up\n  //    3. Some EXDATE entries in the wild seem to have times different from the recurrence rule, but are still excluded by calendar programs.  Not sure how or why.\n  //       These would fail any sort of sane time lookup, because the time literally doesn't match the event.  So we'll ignore time and just use date.\n  //       ex: DTSTART:20170814T140000Z\n  //             RRULE:FREQ=WEEKLY;WKST=SU;INTERVAL=2;BYDAY=MO,TU\n  //             EXDATE:20171219T060000\n  //       Even though \"T060000\" doesn't match or overlap \"T1400000Z\", it's still supposed to be excluded?  Odd. :(\n  // TODO: See if this causes any problems with events that recur multiple times a day.\n  var exdateParam = function (name) {\n    return function (val, params, curr) {\n      var separatorPattern = /\\s*,\\s*/g;\n      curr[name] = curr[name] || [];\n      var dates = val ? val.split(separatorPattern) : [];\n      dates.forEach(function (entry) {\n          var exdate = new Array();\n          dateParam(name)(entry, params, exdate);\n\n          if (exdate[name])\n          {\n            if (typeof exdate[name].toISOString === 'function') {\n              curr[name][exdate[name].toISOString().substring(0, 10)] = exdate[name];\n            } else {\n              console.error(\"No toISOString function in exdate[name]\", exdate[name]);\n            }\n          }\n        }\n      )\n      return curr;\n    }\n  }\n\n  // RECURRENCE-ID is the ID of a specific recurrence within a recurrence rule.\n  // TODO:  It's also possible for it to have a range, like \"THISANDPRIOR\", \"THISANDFUTURE\".  This isn't currently handled.\n  var recurrenceParam = function (name) {\n      return dateParam(name);\n  }\n\n  var addFBType = function (fb, params) {\n    var p = parseParams(params);\n\n    if (params && p){\n      fb.type = p.FBTYPE || \"BUSY\"\n    }\n\n    return fb;\n  }\n\n  var freebusyParam = function (name) {\n    return function(val, params, curr){\n      var fb = addFBType({}, params);\n      curr[name] = curr[name] || []\n      curr[name].push(fb);\n\n      storeParam(val, params, fb);\n\n      var parts = val.split('/');\n\n      ['start', 'end'].forEach(function (name, index) {\n        dateParam(name)(parts[index], params, fb);\n      });\n\n      return curr;\n    }\n  }\n\n  return {\n\n\n    objectHandlers : {\n      'BEGIN' : function(component, params, curr, stack){\n          stack.push(curr)\n\n          return {type:component, params:params}\n        }\n\n      , 'END' : function(component, params, curr, stack){\n        // prevents the need to search the root of the tree for the VCALENDAR object\n        if (component === \"VCALENDAR\") {\n            //scan all high level object in curr and drop all strings\n            var key,\n                obj;\n\n            for (key in curr) {\n                if(curr.hasOwnProperty(key)) {\n                   obj = curr[key];\n                   if (typeof obj === 'string') {\n                       delete curr[key];\n                   }\n                }\n            }\n\n            return curr\n        }\n\n        var par = stack.pop()\n\n        if (curr.uid)\n        {\n        \t// If this is the first time we run into this UID, just save it.\n        \tif (par[curr.uid] === undefined)\n            {\n            \tpar[curr.uid] = curr;\n            }\n            else\n            {\n                // If we have multiple ical entries with the same UID, it's either going to be a\n                // modification to a recurrence (RECURRENCE-ID), and/or a significant modification\n                // to the entry (SEQUENCE).\n\n                // TODO: Look into proper sequence logic.\n\n                if (curr.recurrenceid === undefined)\n                {\n                    // If we have the same UID as an existing record, and it *isn't* a specific recurrence ID,\n                    // not quite sure what the correct behaviour should be.  For now, just take the new information\n                    // and merge it with the old record by overwriting only the fields that appear in the new record.\n                    var key;\n                    for (key in curr) {\n                    \tpar[curr.uid][key] = curr[key];\n                    }\n\n                }\n            }\n\n        \t// If we have recurrence-id entries, list them as an array of recurrences keyed off of recurrence-id.\n        \t// To use - as you're running through the dates of an rrule, you can try looking it up in the recurrences\n        \t// array.  If it exists, then use the data from the calendar object in the recurrence instead of the parent\n        \t// for that day.\n\n        \t// NOTE:  Sometimes the RECURRENCE-ID record will show up *before* the record with the RRULE entry.  In that\n        \t// case, what happens is that the RECURRENCE-ID record ends up becoming both the parent record and an entry\n        \t// in the recurrences array, and then when we process the RRULE entry later it overwrites the appropriate\n\t\t\t// fields in the parent record.\n\n        \tif (curr.recurrenceid != null)\n        \t{\n\n        \t\t// TODO:  Is there ever a case where we have to worry about overwriting an existing entry here?\n\n        \t\t// Create a copy of the current object to save in our recurrences array.  (We *could* just do par = curr,\n        \t\t// except for the case that we get the RECURRENCE-ID record before the RRULE record.  In that case, we\n        \t\t// would end up with a shared reference that would cause us to overwrite *both* records at the point\n\t\t\t\t// that we try and fix up the parent record.)\n        \t\tvar recurrenceObj = new Object();\n        \t\tvar key;\n        \t\tfor (key in curr) {\n        \t\t\trecurrenceObj[key] = curr[key];\n        \t\t}\n\n        \t\tif (recurrenceObj.recurrences != undefined) {\n        \t\t\tdelete recurrenceObj.recurrences;\n        \t\t}\n\n\n\t\t\t\t// If we don't have an array to store recurrences in yet, create it.\n        \t\tif (par[curr.uid].recurrences === undefined) {\n        \t\t\tpar[curr.uid].recurrences = new Array();\n            \t}\n\n        \t\t// Save off our cloned recurrence object into the array, keyed by date but not time.\n        \t\t// We key by date only to avoid timezone and \"floating time\" problems (where the time isn't associated with a timezone).\n\t\t\t\t// TODO: See if this causes a problem with events that have multiple recurrences per day.\n                if (typeof curr.recurrenceid.toISOString === 'function') {\n                  par[curr.uid].recurrences[curr.recurrenceid.toISOString().substring(0,10)] = recurrenceObj;\n                } else {\n                  console.error(\"No toISOString function in curr.recurrenceid\", curr.recurrenceid);\n                }\n            }\n\n        \t// One more specific fix - in the case that an RRULE entry shows up after a RECURRENCE-ID entry,\n        \t// let's make sure to clear the recurrenceid off the parent field.\n        \tif ((par[curr.uid].rrule != undefined) && (par[curr.uid].recurrenceid != undefined))\n            {\n        \t\tdelete par[curr.uid].recurrenceid;\n            }\n\n        }\n        else\n          par[Math.random()*100000] = curr  // Randomly assign ID : TODO - use true GUID\n\n        return par\n      }\n\n      , 'SUMMARY' : storeParam('summary')\n      , 'DESCRIPTION' : storeParam('description')\n      , 'URL' : storeParam('url')\n      , 'UID' : storeParam('uid')\n      , 'LOCATION' : storeParam('location')\n      , 'DTSTART' : dateParam('start')\n      , 'DTEND' : dateParam('end')\n      , 'EXDATE' : exdateParam('exdate')\n      ,' CLASS' : storeParam('class')\n      , 'TRANSP' : storeParam('transparency')\n      , 'GEO' : geoParam('geo')\n      , 'PERCENT-COMPLETE': storeParam('completion')\n      , 'COMPLETED': dateParam('completed')\n      , 'CATEGORIES': categoriesParam('categories')\n      , 'FREEBUSY': freebusyParam('freebusy')\n      , 'DTSTAMP': dateParam('dtstamp')\n      , 'CREATED': dateParam('created')\n      , 'LAST-MODIFIED': dateParam('lastmodified')\n      , 'RECURRENCE-ID': recurrenceParam('recurrenceid')\n\n    },\n\n\n    handleObject : function(name, val, params, ctx, stack, line){\n      var self = this\n\n      if(self.objectHandlers[name])\n        return self.objectHandlers[name](val, params, ctx, stack, line)\n\n      //handling custom properties\n      if(name.match(/X\\-[\\w\\-]+/) && stack.length > 0) {\n          //trimming the leading and perform storeParam\n          name = name.substring(2);\n          return (storeParam(name))(val, params, ctx, stack, line);\n      }\n\n      return storeParam(name.toLowerCase())(val, params, ctx);\n    },\n\n\t\tgetLineBreakChar: function (string) {\n\t\t\tconst indexOfLF = string.indexOf('\\n', 1);  // No need to check first-character\n\n\t\t\tif (indexOfLF === -1) {\n\t\t\t\tif (string.indexOf('\\r') !== -1) return '\\r';\n\n\t\t\t\treturn '\\n';\n\t\t\t}\n\n\t\t\tif (string[indexOfLF - 1] === '\\r') return '\\r?\\n';\n\n\t\t\treturn '\\n';\n\t\t},\n\n    parseICS : function(str){\n      var self = this\n\t\t\tvar line_end_type = self.getLineBreakChar(str)\n      var lines = str.split(line_end_type=='\\n'?/\\n/:/\\r?\\n/)\n      var ctx = {}\n      var stack = []\n\n      for (var i = 0, ii = lines.length, l = lines[0]; i<ii; i++, l=lines[i]){\n        //Unfold : RFC#3.1\n        while (lines[i+1] && /[ \\t]/.test(lines[i+1][0])) {\n          l += lines[i+1].slice(1)\n          i += 1\n        }\n\n        // Split on semicolons except if the semicolon is surrounded by quotes\n        var kv = l.split(/:(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/g)\n\n        if (kv.length < 2){\n          // Invalid line - must have k&v\n          continue;\n        }\n\n        // Although the spec says that vals with colons should be quote wrapped\n        // in practise nobody does, so we assume further colons are part of the\n        // val\n        var value = kv.slice(1).join(\":\")\n          , kp = kv[0].split(\";\")\n          , name = kp[0]\n          , params = kp.slice(1)\n\n        ctx = self.handleObject(name, value, params, ctx, stack, l) || {}\n      }\n\n       // type and params are added to the list of items, get rid of them.\n       delete ctx.type\n       delete ctx.params\n\n       return ctx\n    }\n\n  }\n}))\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}